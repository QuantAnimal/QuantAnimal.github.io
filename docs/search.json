[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Quantification of resilience in farm animals",
    "section": "",
    "text": "This is a supporting website for the paper:\nAnimal Board Invited Review: Quantification of resilience in farm animals. Masoomeh Taghipoor, Matti Pastell, Olivier Martin, Hieu Nguyen Ba, Jaap van Milgen, Andrea Doesch Wilson, Christelle Loncke, Laurence Puillet, Nicolas C Friggens, & Rafael Muñoz-Tamayo. Animal (2023), https://doi.org/10.1016/j.animal.2023.100925\nIt hosts the following code examples to supplement the paper:\n\nDynamic semi-mechanistic model\nDifferential smoothing model\nUsing switching dynamic linear models for detecting perturbations\nExample of an state observer to estimate the perturbed component of the body weight trajectory"
  },
  {
    "objectID": "examples/observer/gobserver_RMT.html",
    "href": "examples/observer/gobserver_RMT.html",
    "title": "Example of an state observer to estimate the perturbed component of the body weight trajectory",
    "section": "",
    "text": "Case study 3. Known theoretical trajectory.\nIn this example, we show the use of state observers to quantify dynamic perturbations. An observer is an object that combines a mathematical model and on-line data to estimate unmeasured variables\n\n knitr::opts_chunk$set(message = FALSE)\n\nlibrary(\"deSolve\")\nlibrary(ggplot2)\nlibrary(ggExtra)\nlibrary(gridExtra)\n\n# Loading the measured noisy data [time (d) animal body weight (kg)]\nynoise  <- read.table(\"ynoise.txt\");\nDN  <- data.frame(ynoise);\ncolnames(DN)<- c(\"time\",\"BW\");\ntN <- DN$time\nyN <- DN$BW\n\n# Loading the measured filtered data [time (d) animal body weight (kg)]\nysmooth <- read.table(\"ysmooth.txt\");\nDS  <- data.frame(ysmooth);\ncolnames(DS)<- c(\"time\",\"BW\");\ntS <- DS$time\nyS <- DS$BW\n\n# Loading the perturbation factor used to generate the simulated data \n\nperturbfactor<- read.table(\"perturbfactor.txt\");\nDP  <- data.frame(perturbfactor);\ncolnames(DP)<- c(\"time\",\"Fi\");\ntP <- DP$time\nyP <- DP$Fi\n\n\n # Dynamic model\ntspan=tS; \n\ndy<- function(t, state,parameters) {  #ODE function observer\n  with(as.list(c(state,parameters)), {\n    \n    # model parameters \n    # p1 = 0.05\n    # p2 = 0.02\n    \n    # observer parameters\n    #w1 =  4.0\n    #w2 =  0.5\n    \n    #ysmooth <- read.table(\"ysmooth.txt\");\n    #DS  <- data.frame(ysmooth);\n    #colnames(DS)<- c(\"time\",\"BW\");\n    #tS <- DS$time\n    #yS <- DS$BW\n    \n    ydata = approx(tS, yS, xout = t)$y # interpolation\n    \n    dy1=-ydata*y2 + ydata*p1*exp(-p2*t) + w1*(ydata-y1)\n    dy2=-w2*y1*w1*(ydata-y1) \n    # return the result\n    list(c(dy1,dy2))\n  }) # end with(as.list ...\n}\n\nstate <- c(y1 = 3,y2=0) #initial conditions\nparameters <- c(p1 = 0.05, p2 = 0.02, w1 = 4.0, w2 = 0.5)\nyout= ode(y = state, times = tspan, func = dy,parms = parameters) # solving the ODE\n\nDout  <- data.frame(yout);\ncolnames(Dout)<- c(\"time\",\"BWobs\",\"Fiobs\");\ntout <- Dout$time # Time\ny1 <- Dout$BWobs  # Estimated body weight\ny2 <- Dout$Fiobs  # Unknown perturbation function \n\n\nggplot(DN, aes(tN, yN)) + geom_point(colour = 'black', size = 2.5)  + labs(title=\"A\", x=\"Time (d)\",  y= \"Body weight (kg)\") +\n  geom_line(data = Dout, aes(tout,y1), size = 1, linetype = 1, colour = \"blue\") \n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\nWarning: Removed 1 row containing missing values (`geom_line()`).\n\n\n\n\nggplot(DP, aes(tP, yP)) + geom_point(colour = 'black', size = 2.5)  + labs(title=\"B\", x=\"Time (d)\", y=expression(phi~ \", perturbation factor\")) +\n  geom_line(data = Dout, aes(tout,y2), size = 1, linetype = 1, colour = \"blue\" )\n\nWarning: Removed 1 row containing missing values (`geom_line()`)."
  },
  {
    "objectID": "examples/post_treatment_of_data/Model_MT.html",
    "href": "examples/post_treatment_of_data/Model_MT.html",
    "title": "Case studies for post treatment of data",
    "section": "",
    "text": "Case study 1.Dynamic semi-mechanistic model\nThe objective of this example is to evaluate the animal’s capacity of response when faced with the two perturbations.\n\n knitr::opts_chunk$set(message = FALSE)\nload(\"DataPert.Rdata\")\n\n  y=function(t){ #Ideal trajectory\n    yl=ymax-ymax*exp(0.1*(-t))\n    return(yl)\n  }\n\nymax=6 #plateau\ntspan=seq(0,130,1)\nplot(tspan,y(tspan), type=\"l\")\npoints(tspan,data$obs)\n\n\n\n\nWe used the following ODE system to describe the influence of these two perturbations on the performance.\n\\[\n\\frac{d\\alpha_j}{dt}=-k_{1j}\\alpha_j \\mathbb{1}_j(t)+k_{2j}(1-\\alpha_j)(1-\\mathbb{1}_j(t));\\\\\n\\alpha_j(t^b)=1;  \\\\\n\\] Where \\(k_{1j}\\) and \\(k_{2j}\\) are model parameters and characterize the animal’s response to perturbation j in term of loss of the performance and recovery capacity, respectively. \\(\\mathbb{1}_i(t))\\) the identity function which is one during the perturbation interval and 0, elsewhere. The value \\(\\alpha_b^j\\) stands for the initial value of the function \\(\\alpha_j\\). Therefore, function \\(\\alpha_j\\) is one in non-perturbed conditions and less than one elsewhere. Then the trajectory of animal performance \\(y(t)\\) during n perturbations can be described as\n\\[\ny(t)=\\Sigma_{j=1}^n \\alpha_j(t).f(P,t), \\\\\ny(t_0)=y_0\n\\] Where f(P,t) describes the theoretical function of animal performance, P is the set of model parameters describing the characteristics of the theoretical trajectory, t is time interval of experiment.\n\n #ODE funccion of perturbations\n  dalpha <- function(t, state, parameters) {\n    with(as.list(c(state, parameters)), {\n      tb1=10\n      te1=25\n      tb2=75\n      te2=85\n      # rate of change\n      da1=k11*(-a1)*(t<te1 &t>tb1)+ k21*(1-a1)*(t>te1&t<tb2)\n      da2=k12*(-a2)*(t<te2 &t>tb2)+ k22*(1-a2)*(t>te2)\n          # return the result\n      list(c(da1,da2))\n    })\n  }\n\n\nlibrary(deSolve)\nlibrary(ggplot2)\n    state <- c(a1 = 1,a2=1) #init var\n    parameters <- c(k11 = .05, k12 = .1, k21=0.15,k22=0.05)\n    alpha= ode(y = state, times = tspan, func = dalpha, parms = parameters) #alpha1 et 2: 1st and 2nd pertubations\nalpha=as.data.frame(alpha)\n data.test=as.data.frame(cbind(alpha,y(tspan),data$obs,(alpha[2]+alpha[3])/2*y(tspan)))\n colnames(data.test)=c(\"time\",\"alpha1\",\"alpha2\",\"perf\",\"obs\",\"pert\")\n# alpha1 et 2: 1st and 2nd pertubations\n# perf: animal ideal trajectory of performance\n# pert: actual perturbed performance\n head(data.test)\n\n  time alpha1 alpha2      perf         obs      pert\n1    0      1      1 0.0000000 -0.07053181 0.0000000\n2    1      1      1 0.5709755  0.28091643 0.5709755\n3    2      1      1 1.0876155  0.79499282 1.0876155\n4    3      1      1 1.5550907  1.86957724 1.5550907\n5    4      1      1 1.9780797  1.76087134 1.9780797\n6    5      1      1 2.3608160  2.36518639 2.3608160\n\ncol=c(\"Theoretical Performance\",\"Estimated response\",\"Observation\")\nggplot(data = data.test, aes(x = tspan)) +\n  geom_line(aes( y = perf, color = col[1]))+\n  geom_line(aes( y = pert, color = col[2]))+\n  geom_point(aes( y = obs, color = col[3]))\n\n\n\n\nThe fihure above shows a hypothetic example of animal response to two different perturbations. Two consecutive perturbations occurred at \\(t_1^b=10\\) and \\(t_2^b=75\\), and were over at \\(t_1^s=25\\) and \\(t_2^s=85\\) days of age. Parameters of animal’s response \\((k_{1j},k_{2j})\\) are \\((0.05,0.15)\\) for the first perturbation and \\((0.1,0.05)\\) for the second. One can easily realize that the animal had a better capacity to resist faced with the first perturbation, while the capacity of recovery was better in the second perturbation. Moreover, compared to the second perturbation (10 days), the animal took more time to start the recovery period in the first perturbation (15 days).\n\n\nCase study 2. Differential smoothing model\nThis example shows the use of a purely data-driven approach for the post treatment of performance data under perturbations. We present a hypothetic example, in which the expected performance is equal to 1, and the deviations from this value could be considered as perturbations.\n\nlibrary(\"fda\")\nlibrary(\"graphics\")\n\nload(\"data_FDA.Rdata\")\nwrite.table(data$obs, file=\"data_FDA\", append = FALSE, sep = \" \", dec = \".\",\n            row.names = TRUE, col.names = TRUE)\nplot(data$time,data$obs)\n\n\n\n\nData were smoothed using B-Spline bases of order 5 with the roughness penalty \\(\\lambda=10^4\\) to estimate animal performance.\n\n#FDA\ntspan=seq(0,130,1)\norder = 6\npen.what = 4\nlambda = 10^4\nrange = c(data$time[1],data$time[length(data$time)])\nknot.vec = seq(1, length(data$time),2)\nbreak.vec = data$time[knot.vec]\n\n# B-spline regression\n    basis.func = create.bspline.basis(rangeval = range, norder = order, breaks = break.vec)\n    param.func = fdPar(fdobj = basis.func, Lfdobj = pen.what,lambda = lambda)\n    smooth.res = smooth.basis(argvals = data$time,data$obs,param.func)\n\nres.fda = smooth.res$fd\neval.days =data$time\n\n    res.estim   = eval.fd(eval.days,res.fda)   #\n    vel.estim = eval.fd(eval.days,res.fda,1) #\n    acc.estim = eval.fd(eval.days,res.fda,2) #\n\ndata$res = res.estim\ndata$deriv=vel.estim\ndata$acc=acc.estim\n\n   Vars=c(\"perturbed perfromance\", \"Observation\",\"Theoretical_perfomance\")\n  p1= ggplot(data = data, aes(x = time)) +\n    geom_line(aes( y = res, color = Vars[1]))+\n    geom_point(aes( y = obs, color = Vars[2]))+\n    geom_line(aes( y = perf, color = Vars[3]))\n\n    var=c(\"1st derivative\")\n  p2=  ggplot(data = data, aes(x = time)) +\n    geom_line(aes( y = vel.estim, color = var[1])) +\n    geom_line(aes( y = 0))\n\ntheme_set(theme_classic())\nupdate_geom_defaults(\"line\", list(size = 1.1))\n\ngridExtra::grid.arrange(p1, p2)\n\n\n\n\nThe upper graph shows the estimated function (black curve) against observation (dots). The lower graph shows the derivative of the estimated function. Zeros of derivatives are associated with maximums and minimums of the function. The blue line on the upper graph shows the theoretical performance of the animal, which is assumed to be 1."
  },
  {
    "objectID": "examples/switching_model/switching_model.html",
    "href": "examples/switching_model/switching_model.html",
    "title": "Using switching dynamic linear models for detecting perturbations",
    "section": "",
    "text": "We present an example on online estimation of perturbations of animal trajectory using a switching dynamic linear model. We use one dynamic model for the unperturbed state and a separate model for the perturbed state, and a discrete latent variable \\(s_t \\in {\\{unperturbed,perturbed\\}}\\) indicates which model is active at each time. By observing the data we see that in the unperturbed state the series has a constant mean and in the perturbed state there is clear change in the slope. This document is a supplement to paper “Quantification of resilience in farm animals” by Taghipoor et al.\nWe model the unperturbed state using a local level model (1st order polynomial) and the perturbed state using a local linear trend model (2nd order polynomial). In the local level model observations are modeled as having mean \\(\\mu_t\\) which is subject to random changes over time. The local level model is given by:\nThe local linear trend model additionally expects the level \\(\\mu_t\\) to evolve with a slope of \\(\\beta_t\\). The local linear trend model is defined as:\nWe will use the dlm package to fit the models, the package provide model design function dlmModPoly for defining polynomial DLMs. We start by estimating the parameters of the models using maximum likelihood (see vignette(\"dlm\") for an introduction of the package explanation of estimation using dlmMLE).\nApply the filters and plot the results\nWe notice that the model provide too noisy estimates of the filtered state for our application, this could be because the data contains 2 separate regimes. We refit the model with higher values for V and W. In a real online application the model parameters are usually estimated on training data obtained from experiments or farm records. After refitting we are happy with estimates for this application.\nWe observe that local level model provides good fit for the data for first part of the series and that the estimates from the linear trend model are clearly noisier. However, when the value of observations drop sharply the linear trend model performs clearly better and the local level model is no longer able to track the observations. Next we’ll see how we can detect which model is more appropriate for each observation."
  },
  {
    "objectID": "examples/switching_model/switching_model.html#switching-model",
    "href": "examples/switching_model/switching_model.html#switching-model",
    "title": "Using switching dynamic linear models for detecting perturbations",
    "section": "Switching model",
    "text": "Switching model\nIn order to determine the system state based on our observations and 2 DLMs we need to be able to estimate the posterior probability of a model being the correct one for each sample \\(y_t\\). We will apply a multiprocess class I model from West & Harrison (1997) with added transition propabilities.\nWe choose the prior probability for each model to be equal:\n\\[prior = [0.5, 0.5]\\]\n\nprior <- c(0.5, 0.5)\n\nThe likelihood \\(l(s)_t\\) of each model at time \\(t\\) is obtained from standard Kalman filter recursions. The dlm package only provides the function dlmLL for calculating the loglikelihood of the entire fitted series. We have added a function (based on dlmLL) to calculate likelihood for each sample in dlmLikelihood.R. Also the 1 step ahead forecast errors could be used in the model instead of likelihoods by replacing the calls to dlmLikelihood with abs(resid(f1)$res).\n\nsource(\"dlmLikelihood.R\")\nll1 <- dlmLikelihood(y, m1)\nll2 <- dlmLikelihood(y, m2)\nll <- data.frame(ll1, ll2)\n\nWe calculate the posterior probability for each state based on our prior and likelihood ratio of the states and plot the results. The gamma matrix is used to set the state transition probability, if you want the make the state switches more sensitive try changing it e.g. to matrix(c(0.9, .1, .1, .9), ncol=2)\n\n# Calculate posterior probabilities of model\nposterior_probability <- function(ll, gamma, prior){\n  T <- nrow(ll)\n  posterior_probs <- data.frame(array(0, dim = c(T,ncol(ll))))\n  for (t in 1:T){\n    posterior <- gamma %*% prior * as.numeric(ll[t,])\n    prior <- posterior/sum(posterior) # posterior becomes prior for t+1\n    posterior_probs[t, ] <- prior\n  }\n  return(posterior_probs)\n}\n\ng1 <- matrix(c(0.95, .05, .05, .95), ncol=2)\n\npp1 <- posterior_probability(ll, g1, prior)\n\nWe obtain the state at time T by selecting the column with the highest posterior probability from matrix pp1. The figure below shows the filtered state estimate for both of the model, the probability of each being active and the estimated slope of y_t for the second order model. The linear trend model has higher posterior probability during the perturbations and provides an online estimate of timing of perturbations that can be used to make management decisions. The online estimate of slope has similar shape to one provided by the differential smoothing method example.\n\nstates <- function(x){apply(x, 1, which.max)}\n\nlibrary(ggplot2)\nnames(pp1) <- c(\"p1\", \"p2\")\ndf <- data.frame(t = 1:length(y), y, f1 = f1$f, f2 = f2$f,  pp1, state = states(pp1), slope = dropFirst(f2$m[,2]))\np_df <- rbind(data.frame(t = 1:length(y), p = pp1$p1, Model = \"1st order\"),\n              data.frame(t = 1:length(y), p = pp1$p2, Model = \"2nd order\")\n              )\np1 <- ggplot(df, aes(x = t, y = y)) + geom_point() +\n  geom_line(aes(x=t, y=f1, col=factor(1))) +\n  geom_line(aes(x=t, y=f2, col = factor(2))) +\n  scale_colour_discrete(name  =\"Model\", labels=c(\"1st order\", \"2nd order\"))\n\n\np2 <- ggplot(p_df, aes(y = p, x=t)) + geom_line(aes(color = Model))\np3 <- ggplot(df, aes(y = slope, x=t, color=\"1\")) + geom_line() + ylim(c(-0.02, 0.02)) +\n  scale_colour_discrete(name  =\"Model\", labels=c(\"2nd order\"))\n\ntheme_set(theme_classic())\nupdate_geom_defaults(\"line\", list(size = 1.1))\n\ngridExtra::grid.arrange(p1, p2, p3)"
  },
  {
    "objectID": "examples/switching_model/switching_model.html#references",
    "href": "examples/switching_model/switching_model.html#references",
    "title": "Using switching dynamic linear models for detecting perturbations",
    "section": "References",
    "text": "References\nGiovanni Petris (2010). An R Package for Dynamic Linear Models. Journal of Statistical Software, 36(12), 1-16. URL: https://www.jstatsoft.org/v36/i12/.\nPetris, Petrone, and Campagnoli. (2009). Dynamic Linear Models with R. https://link.springer.com/book/10.1007/b135794\nWest, M. & Harrison J. (1997) Bayesian Forecasting and Dynamic Models. https://link.springer.com/book/10.1007/b98971"
  }
]